"""
Sample: Evaluatuate all scenes

This module demonstrates evaluating data from all scene using the stereomideval module.
For demonstration purposes the test data is generated by adding noise to the ground truth
"""
import os
import numpy as np
from stereomideval import Dataset, Eval
from i3drsgm import I3DRSGM, StereoSupport
import time
import cv2
import ssl
import glob

def puttext_multiline(img, text, org, font,  
                    fontScale, color, thickness, lineType=cv2.LINE_AA, line_spacing=1.5, outline_color=None):
    """
    Draws multiline with an outline.
    """
    assert isinstance(text, str)

    uv_top_left = np.array(org, dtype=float)
    assert uv_top_left.shape == (2,)

    for line in text.splitlines():
        (w, h), _ = cv2.getTextSize(
            text=line,
            fontFace=font,
            fontScale=fontScale,
            thickness=thickness,
        )
        uv_bottom_left_i = uv_top_left + [0, h]
        org = tuple(uv_bottom_left_i.astype(int))

        if outline_color is not None:
            cv2.putText(
                img,
                text=line,
                org=org,
                fontFace=font,
                fontScale=fontScale,
                color=outline_color,
                thickness=thickness * 3,
                lineType=lineType,
            )
        cv2.putText(
            img,
            text=line,
            org=org,
            fontFace=font,
            fontScale=fontScale,
            color=color,
            thickness=thickness,
            lineType=lineType,
        )

        uv_top_left += [0, h * line_spacing]

    return img

def display_results(left_image,gt_disp,test_disp,rmse,bad_pix_error,match_time):
    # remove negative disparities
    test_disp[test_disp<0]=0.0
    gt_disp[gt_disp<0]=0.0
    # Replace nan and inf values with zero
    test_disp = np.nan_to_num(test_disp, nan=0.0,posinf=0.0,neginf=0.0)
    gt_disp = np.nan_to_num(gt_disp, nan=0.0,posinf=0.0,neginf=0.0)
    # normalise image
    test_disp = cv2.normalize(test_disp, None, 0, 255, cv2.NORM_MINMAX)
    gt_disp = cv2.normalize(gt_disp, None, 0, 255, cv2.NORM_MINMAX)
    # convert to uint8 (required by applyColorMap function)
    test_disp = test_disp.astype(np.uint8)
    gt_disp = gt_disp.astype(np.uint8)
    # apply colormap
    test_disp = cv2.applyColorMap(test_disp, cv2.COLORMAP_JET)
    gt_disp = cv2.applyColorMap(gt_disp, cv2.COLORMAP_JET)
    # Resize colormap image for displaying in window
    test_disp = StereoSupport.image_resize(test_disp, width=480)
    gt_disp = StereoSupport.image_resize(gt_disp, width=480)
    left_image = StereoSupport.image_resize(left_image, width=480)
    # Concatinate images
    display_image = cv2.hconcat([left_image, gt_disp, test_disp])

    # Print metrics on display image
    msg = "Match time {:.2f}s\n".format(match_time)
    msg += "RMSE: {:.2f}\n".format(rmse)
    msg += "Bad pixel 2.0: {:.2f}%\n".format(bad_pix_error)
    print(msg)
    display_image = puttext_multiline(
        img=display_image, text=msg, org=(10, 10), font=cv2.FONT_HERSHEY_TRIPLEX,  
        fontScale=0.7, color=(0, 0, 0), thickness=1, outline_color=(255,255,255))
    # Display in OpenCV window
    cv2.imshow("Result", display_image)
    cv2.waitKey(250)

dataset_folder = os.path.join(os.getcwd(),"datasets") #Path to dowmload datasets

# Create dataset folder
if not os.path.exists(dataset_folder):
    os.makedirs(dataset_folder)

# SSL Verificaiton may be need if you get the following error:
# "urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1091)>"
ssl._create_default_https_context = ssl._create_unverified_context

min_disp = 0
disp_range = 16*270
interp = False

# Initalise I3DRSGM
i3drsgm = I3DRSGM(glob.glob("*.lic")[0])
# Check initalisation was success
if i3drsgm.isInit():
    image_height, image_width = 0,0
    # Get list of scenes in Milddlebury's stereo dataset (2014) and iterate through them
    for scene_name in Dataset.get_scene_list():
        # Download dataset from middlebury servers
        # will only download it if it hasn't already been downloaded
        print("Downloading data for scene '"+scene_name+"'...")
        Dataset.download_scene_data(scene_name,dataset_folder)
        # Load scene data from downloaded folder
        print("Loading data for scene '"+scene_name+"'...")
        scene_data = Dataset.load_scene_data(scene_name,dataset_folder,False)
        # Get test data and ground truth
        left_image = scene_data.left_image
        right_image = scene_data.right_image
        gt_disp_image = scene_data.disp_image
        # Get test data image dims
        new_image_height = left_image.shape[0]
        new_image_width = left_image.shape[1]
        if new_image_height != image_height or new_image_width != image_width:
            # Re generate i3drsgm if image height is different
            i3drsgm.close()
            i3drsgm = I3DRSGM("2020_02_21_I3DRWL001_WINDOWS.lic")
            # Set matcher parameters
            i3drsgm.setMinDisparity(min_disp)
            i3drsgm.setDisparityRange(disp_range)
            i3drsgm.enableInterpolation(interp)
            image_height, image_width = new_image_height, new_image_width
        # Record time at start of match
        start_time = time.time()
        # Stereo match image pair
        print("Running I3DRSGM on images...")
        valid, test_disp_image = i3drsgm.forwardMatch(left_image,right_image)
        # Record time elapsed for match
        match_time = time.time() - start_time
        if valid:
            # I3DRSGM result is negative, invert it
            test_disp_image = -test_disp_image.astype(np.float32)
            # Non matched pixel have value of 99999, replace with zero (zero is ignored in evaluation)
            test_disp_image[test_disp_image==99999]=0.0
            # Evaluate stereo match
            rmse = Eval.rmse(gt_disp_image,test_disp_image)
            bad_pix_error = Eval.bad_pix_error(gt_disp_image,test_disp_image)
            # Display results
            display_results(left_image,gt_disp_image,test_disp_image,rmse,bad_pix_error,match_time)
# Required to release memory
i3drsgm.close()


"""
Sample: Evaluatuate all scenes

This module demonstrates evaluating data from all scene using the stereomideval module.
For demonstration purposes the test data is generated by adding noise to the ground truth
"""
import os
import shutil
import glob
import ssl
import numpy as np
import cv2
from stereomideval.structures import MatchData, DatasetType
from stereomideval.dataset import Dataset, SceneInfo
from stereomideval.eval import Eval, Timer
from stereomideval import colormap_disp, image_resize
from i3drsgm import I3DRSGM, I3DRSGMAppAPI

DATASET_FOLDER = os.path.join(os.getcwd(),"datasets") #Path to download datasets
EVAL_FOLDER = os.path.join(os.getcwd(),"evaluation") #Path to store evaluation
GET_METRIC_RANK = False
GET_AV_METRIC_RANK = True
MIN_DISP = 0
DISP_RANGE = 16*250
WINDOW_SIZE = 5
PYRAMID_LEVEL = 6
INTERP = True
DOWNSAMPLE_RATE = 0.25

#I3DRSGMAppAPI.download_app("1.0.9",True)

# SSL Verificaiton may be need if you get the following error:
# "urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1091)>"
ssl._create_default_https_context = ssl._create_unverified_context

# Create dataset folder
if not os.path.exists(DATASET_FOLDER):
    os.makedirs(DATASET_FOLDER)

# Create eval folder
if os.path.exists(EVAL_FOLDER):
    shutil.rmtree(EVAL_FOLDER)
os.makedirs(EVAL_FOLDER)

# Initalise I3DRSGM
license_files = glob.glob("*.lic")
if (len(license_files) <= 0):
    raise Exception("Failed to find license file in script directory.")
license_file = license_files[0]
i3drsgm = I3DRSGM(license_file)
# Check initalisation was success
if i3drsgm.isInit():
    image_height, image_width = 0,0
    match_data_list = []
    # Get list of scenes in Milddlebury's stereo training dataset and iterate through them
    #scene_info = SceneInfo(Dataset.Teddy, DatasetType.imperfect, 1.0)
    for scene_info in Dataset.get_training_scene_list():
        scene_name=scene_info.scene_name
        dataset_type=scene_info.dataset_type
        # Download dataset from middlebury servers
        # will only download it if it hasn't already been downloaded
        print("Downloading data for scene '"+scene_name+"'...")
        Dataset.download_scene_data(scene_name,DATASET_FOLDER,dataset_type)
        # Load scene data from downloaded folder
        print("Loading data for scene '"+scene_name+"'...")
        scene_data = Dataset.load_scene_data(
            scene_name=scene_name,dataset_folder=DATASET_FOLDER,
            dataset_type=dataset_type)
        left_image = scene_data.left_image
        right_image = scene_data.right_image
        ground_truth = scene_data.disp_image
        ndisp = scene_data.ndisp * DOWNSAMPLE_RATE
        #ndisp = np.amax(ground_truth) * 4
        #ndisp = ndisp * DOWNSAMPLE_RATE

        disp_range = DISP_RANGE

        left_image = cv2.resize(left_image,fx=DOWNSAMPLE_RATE,fy=DOWNSAMPLE_RATE,interpolation=cv2.INTER_AREA,dsize=None)
        right_image = cv2.resize(right_image,fx=DOWNSAMPLE_RATE,fy=DOWNSAMPLE_RATE,interpolation=cv2.INTER_AREA,dsize=None)
        ground_truth = cv2.resize(ground_truth,fx=DOWNSAMPLE_RATE,fy=DOWNSAMPLE_RATE,interpolation=cv2.INTER_AREA,dsize=None)
        orig_dtype = ground_truth.dtype
        ground_truth = ground_truth.astype(np.float32)
        ground_truth *= DOWNSAMPLE_RATE
        ground_truth = ground_truth.astype(orig_dtype)

        # Get test data image dims
        new_image_height = left_image.shape[0]
        new_image_width = left_image.shape[1]
        print("{},{}".format(new_image_height,new_image_width))
        if new_image_height != image_height or new_image_width != image_width:
            # Re generate i3drsgm if image height is different
            i3drsgm.close()
            i3drsgm = I3DRSGM(license_file)
            # Set matcher parameters
            res = i3drsgm.setWindowSize(WINDOW_SIZE)
            res &= i3drsgm.setMinDisparity(MIN_DISP)
            res &= i3drsgm.setDisparityRange(disp_range)
            res &= i3drsgm.setPyamidLevel(PYRAMID_LEVEL)
            res &= i3drsgm.enableInterpolation(INTERP)
            image_height, image_width = new_image_height, new_image_width

        # Start timer
        timer = Timer()
        timer.start()

        # Stereo match image pair
        print("Running I3DRSGM on images...")
        valid, test_disp_image = i3drsgm.forwardMatch(left_image,right_image)

        # Record elapsed time for match
        elapsed_time = timer.elapsed()

        # I3DRSGM result is negative, invert it
        test_disp_image = -test_disp_image.astype(np.float32)
        # Non matched pixel have value of 99999, replace with zero (zero is ignored in evaluation)
        test_disp_image[test_disp_image==99999]=0.0
        test_disp_image[test_disp_image<=0]=0.0
        test_disp_image[test_disp_image>=ndisp]=ndisp
        test_disp_image = np.nan_to_num(test_disp_image, nan=0.0,posinf=0.0,neginf=0.0)
        test_disp_image = test_disp_image.astype(ground_truth.dtype)

        #print(ndisp)
        #print(ground_truth)
        #print(test_disp_image)

        if valid:
            match_result = MatchData.MatchResult(
                left_image,right_image,ground_truth,test_disp_image,elapsed_time,ndisp)
            Eval.display_results(match_result,wait=1)
            match_data = MatchData(scene_info,match_result)
            match_data_list.append(match_data)
            #resize_disp_image = image_resize(colormap_disp(test_disp_image),width=480)
            #cv2.imshow("Match",resize_disp_image)
            #cv2.waitKey(0)
        else:
            i3drsgm.close()
            raise Exception("Match failed!")

    # Required to release memory
    i3drsgm.close()

    Eval.evaluate_match_data_list(match_data_list,GET_METRIC_RANK,GET_AV_METRIC_RANK,INTERP)
    #Eval.evaluate_match_result_list()
else:
    # Required to release memory
    i3drsgm.close()
